.. include:: ../_header.rst

The awake event
~~~~~~~~~~~~~~~

We propose using Phaser_ events for implementing the User Components behaviors. However, the events provided in Phaser_ are not enough. When you create a component, all properties are set with the default values. Then, you set the value of each property. However, maybe you want to perform a custom initialization routine after all properties are set.

Looking into the Phaser_ events, you can do it in the first scene's update. It means you can listen once for the **UPDATE** event and run the initialization routine. It may work in many cases. But maybe, you want to run this routine just after all properties are set, and before the game starts the update loop.

For this reason, the |SceneCompiler|_ generates code for emitting a custom event, the ``scene-awake`` event, just after it generates the code that creates the objects in the scene, and all their properties are set:
.. code::

    // code generated by the compiler:

    editorCreate() {
    
        // creates the game object
        const dino = this.add.image(400, 240, "FufuSuperDino");
        
        // creates the PushOnClick component
        const dinoPushOnClick = new PushOnClick(dino);

        // sets the component's properties
        dinoPushOnClick.pushDelay = 500;

        // emit the scene-awake event, after all objects are created
        // and all properties are set
        dino.emit("scene-awake");
    }

When you implement a component, you can register a listener on the **scene-awake** event:

.. code::

    class PushOnClick {

        constructor(gameObject) {
            ...
            
            this.gameObject = gameObject;

            gameObject.scene.events.once("scene-awake", () => {

                // here I init the component

                // I register a "pointerdown"
                // event for "animating" the game object
                // with a push effect
                this.gameObject.setInteractive()
                    .on("pointerdown", () => {
                        // animate the object with the push effect
                        this.gameObject.scene.add.tween(...);
                    });
            });
        }
    }

In the section `A base class for your components <./user-components-super-class.html>`_), we explain how you can use a common super-class for all the components. It simplifies the listening of Phaser_ events, and it also includes the **scene-awake** event. So you can rewrite the previous **PushOnClick** component in this way:

.. code::

    class PushOnClick extends UserComponent {

        constructor(gameObject) {
            super(gameObject);
        }

        awake() {

            // Instead of registering an event listener
            // you can override this method.

            this.gameObject.setInteractive()
                .on("pointerdown", () => {
                    // animate the object with the push effect
                    this.gameObject.scene.add.tween(...);
                });
        }
    }

The ``scene-awake`` event is emitted in the ``editorCreate()`` method of a scene. So, if you create a new component and this component listens to the ``scene-awake`` event, then you should emit that event manually:

.. code::

    const myComp = new MyComponent(someSprite);
    // emit the awake event so the component can be notified
    this.events.emit("scene-awake");

Emitting the ``scene-awake`` event later in the game is safe because components and prefabs_ handle this event only once in their lifetime.